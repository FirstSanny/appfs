<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>appfs: /OPTI/bzfdinse/appfs/Dinsel/venv/lib/python3.5/site-packages/numpy/doc/internals.py Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">appfs
   &#160;<span id="projectnumber">1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b51dbb6a9fdf705bef6f1d989db2f1ee.html">OPTI</a></li><li class="navelem"><a class="el" href="dir_26b9974e5b45d02070e599411d8cdb78.html">bzfdinse</a></li><li class="navelem"><a class="el" href="dir_14616f07bb336181b53dfe8f5d723bd0.html">appfs</a></li><li class="navelem"><a class="el" href="dir_ac212ff621c3d31cd8f53e0d5b8bf37b.html">Dinsel</a></li><li class="navelem"><a class="el" href="dir_83966e9ec3b7bb31abd44c7f5ce46ab3.html">venv</a></li><li class="navelem"><a class="el" href="dir_e13dc5a1a0c0104e598bfb1503bb915b.html">lib</a></li><li class="navelem"><a class="el" href="dir_d60bb951f0c174a459eada8277b369c9.html">python3.5</a></li><li class="navelem"><a class="el" href="dir_42b0a2b78d0a4f275f6b246b71d2076d.html">site-packages</a></li><li class="navelem"><a class="el" href="dir_def7250de60b9e1361e4ef24fd88481e.html">numpy</a></li><li class="navelem"><a class="el" href="dir_267aab4536ad07c81ba91107fc0d38d5.html">doc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">internals.py</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="stringliteral">&quot;&quot;&quot;</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="stringliteral">===============</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="stringliteral">Array Internals</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="stringliteral">===============</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="stringliteral">Internal organization of numpy arrays</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="stringliteral">=====================================</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="stringliteral">It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&#39;s book &quot;Guide to NumPy&quot;.</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="stringliteral">NumPy arrays consist of two major components, the raw array data (from now on,</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="stringliteral">referred to as the data buffer), and the information about the raw array data.</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="stringliteral">The data buffer is typically what people think of as arrays in C or Fortran,</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="stringliteral">a contiguous (and fixed) block of memory containing fixed sized data items.</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="stringliteral">NumPy also contains a significant set of data that describes how to interpret</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="stringliteral">the data in the data buffer. This extra information contains (among other things):</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="stringliteral"> 1) The basic data element&#39;s size in bytes</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="stringliteral"> 2) The start of the data within the data buffer (an offset relative to the</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="stringliteral">    beginning of the data buffer).</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="stringliteral"> 3) The number of dimensions and the size of each dimension</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="stringliteral"> 4) The separation between elements for each dimension (the &#39;stride&#39;). This</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="stringliteral">    does not have to be a multiple of the element size</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="stringliteral"> 5) The byte order of the data (which may not be the native byte order)</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="stringliteral"> 6) Whether the buffer is read-only</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="stringliteral"> 7) Information (via the dtype object) about the interpretation of the basic</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="stringliteral">    data element. The basic data element may be as simple as a int or a float,</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="stringliteral">    or it may be a compound object (e.g., struct-like), a fixed character field,</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="stringliteral">    or Python object pointers.</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="stringliteral"> 8) Whether the array is to interpreted as C-order or Fortran-order.</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="stringliteral">This arrangement allow for very flexible use of arrays. One thing that it allows</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="stringliteral">is simple changes of the metadata to change the interpretation of the array buffer.</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="stringliteral">Changing the byteorder of the array is a simple change involving no rearrangement</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="stringliteral">of the data. The shape of the array can be changed very easily without changing</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="stringliteral">anything in the data buffer or any data copying at all</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="stringliteral">Among other things that are made possible is one can create a new array metadata</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="stringliteral">object that uses the same data buffer</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="stringliteral">to create a new view of that data buffer that has a different interpretation</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="stringliteral">of the buffer (e.g., different shape, offset, byte order, strides, etc) but</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="stringliteral">shares the same data bytes. Many operations in numpy do just this such as</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="stringliteral">slices. Other operations, such as transpose, don&#39;t move data elements</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="stringliteral">around in the array, but rather change the information about the shape and strides so that the indexing of the array changes, but the data in the doesn&#39;t move.</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="stringliteral">Typically these new versions of the array metadata but the same data buffer are</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="stringliteral">new &#39;views&#39; into the data buffer. There is a different ndarray object, but it</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="stringliteral">uses the same data buffer. This is why it is necessary to force copies through</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="stringliteral">use of the .copy() method if one really wants to make a new and independent</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="stringliteral">copy of the data buffer.</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="stringliteral">New views into arrays mean the object reference counts for the data buffer</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="stringliteral">increase. Simply doing away with the original array object will not remove the</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="stringliteral">data buffer if other views of it still exist.</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="stringliteral">Multidimensional Array Indexing Order Issues</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="stringliteral">============================================</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="stringliteral">What is the right way to index</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="stringliteral">multi-dimensional arrays? Before you jump to conclusions about the one and</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="stringliteral">true way to index multi-dimensional arrays, it pays to understand why this is</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="stringliteral">a confusing issue. This section will try to explain in detail how numpy</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="stringliteral">indexing works and why we adopt the convention we do for images, and when it</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="stringliteral">may be appropriate to adopt other conventions.</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="stringliteral">The first thing to understand is</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="stringliteral">that there are two conflicting conventions for indexing 2-dimensional arrays.</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="stringliteral">Matrix notation uses the first index to indicate which row is being selected and</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="stringliteral">the second index to indicate which column is selected. This is opposite the</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="stringliteral">geometrically oriented-convention for images where people generally think the</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="stringliteral">first index represents x position (i.e., column) and the second represents y</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="stringliteral">position (i.e., row). This alone is the source of much confusion;</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="stringliteral">matrix-oriented users and image-oriented users expect two different things with</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="stringliteral">regard to indexing.</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="stringliteral">The second issue to understand is how indices correspond</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="stringliteral">to the order the array is stored in memory. In Fortran the first index is the</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="stringliteral">most rapidly varying index when moving through the elements of a two</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="stringliteral">dimensional array as it is stored in memory. If you adopt the matrix</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="stringliteral">convention for indexing, then this means the matrix is stored one column at a</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="stringliteral">time (since the first index moves to the next row as it changes). Thus Fortran</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="stringliteral">is considered a Column-major language. C has just the opposite convention. In</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="stringliteral">C, the last index changes most rapidly as one moves through the array as</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="stringliteral">stored in memory. Thus C is a Row-major language. The matrix is stored by</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="stringliteral">rows. Note that in both cases it presumes that the matrix convention for</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="stringliteral">indexing is being used, i.e., for both Fortran and C, the first index is the</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="stringliteral">row. Note this convention implies that the indexing convention is invariant</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="stringliteral">and that the data order changes to keep that so.</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="stringliteral">But that&#39;s not the only way</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="stringliteral">to look at it. Suppose one has large two-dimensional arrays (images or</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="stringliteral">matrices) stored in data files. Suppose the data are stored by rows rather than</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="stringliteral">by columns. If we are to preserve our index convention (whether matrix or</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="stringliteral">image) that means that depending on the language we use, we may be forced to</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="stringliteral">reorder the data if it is read into memory to preserve our indexing</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="stringliteral">convention. For example if we read row-ordered data into memory without</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="stringliteral">reordering, it will match the matrix indexing convention for C, but not for</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="stringliteral">Fortran. Conversely, it will match the image indexing convention for Fortran,</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="stringliteral">but not for C. For C, if one is using data stored in row order, and one wants</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="stringliteral">to preserve the image index convention, the data must be reordered when</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="stringliteral">reading into memory.</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="stringliteral">In the end, which you do for Fortran or C depends on</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="stringliteral">which is more important, not reordering data or preserving the indexing</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="stringliteral">convention. For large images, reordering data is potentially expensive, and</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="stringliteral">often the indexing convention is inverted to avoid that.</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="stringliteral">The situation with</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="stringliteral">numpy makes this issue yet more complicated. The internal machinery of numpy</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="stringliteral">arrays is flexible enough to accept any ordering of indices. One can simply</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="stringliteral">reorder indices by manipulating the internal stride information for arrays</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="stringliteral">without reordering the data at all. NumPy will know how to map the new index</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="stringliteral">order to the data without moving the data.</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="stringliteral">So if this is true, why not choose</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="stringliteral">the index order that matches what you most expect? In particular, why not define</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="stringliteral">row-ordered images to use the image convention? (This is sometimes referred</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="stringliteral">to as the Fortran convention vs the C convention, thus the &#39;C&#39; and &#39;FORTRAN&#39;</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="stringliteral">order options for array ordering in numpy.) The drawback of doing this is</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="stringliteral">potential performance penalties. It&#39;s common to access the data sequentially,</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="stringliteral">either implicitly in array operations or explicitly by looping over rows of an</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="stringliteral">image. When that is done, then the data will be accessed in non-optimal order.</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="stringliteral">As the first index is incremented, what is actually happening is that elements</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="stringliteral">spaced far apart in memory are being sequentially accessed, with usually poor</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="stringliteral">memory access speeds. For example, for a two dimensional image &#39;im&#39; defined so</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="stringliteral">that im[0, 10] represents the value at x=0, y=10. To be consistent with usual</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="stringliteral">Python behavior then im[0] would represent a column at x=0. Yet that data</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="stringliteral">would be spread over the whole array since the data are stored in row order.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="stringliteral">Despite the flexibility of numpy&#39;s indexing, it can&#39;t really paper over the fact</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="stringliteral">basic operations are rendered inefficient because of data order or that getting</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="stringliteral">contiguous subarrays is still awkward (e.g., im[:,0] for the first row, vs</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="stringliteral">im[0]), thus one can&#39;t use an idiom such as for row in im; for col in im does</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="stringliteral">work, but doesn&#39;t yield contiguous column data.</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="stringliteral">As it turns out, numpy is</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="stringliteral">smart enough when dealing with ufuncs to determine which index is the most</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="stringliteral">rapidly varying one in memory and uses that for the innermost loop. Thus for</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="stringliteral">ufuncs there is no large intrinsic advantage to either approach in most cases.</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="stringliteral">On the other hand, use of .flat with an FORTRAN ordered array will lead to</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="stringliteral">non-optimal memory access as adjacent elements in the flattened array (iterator,</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="stringliteral">actually) are not contiguous in memory.</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="stringliteral">Indeed, the fact is that Python</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="stringliteral">indexing on lists and other sequences naturally leads to an outside-to inside</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="stringliteral">ordering (the first index gets the largest grouping, the next the next largest,</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="stringliteral">and the last gets the smallest element). Since image data are normally stored</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="stringliteral">by rows, this corresponds to position within rows being the last item indexed.</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="stringliteral">If you do want to use Fortran ordering realize that</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="stringliteral">there are two approaches to consider: 1) accept that the first index is just not</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="stringliteral">the most rapidly changing in memory and have all your I/O routines reorder</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="stringliteral">your data when going from memory to disk or visa versa, or use numpy&#39;s</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="stringliteral">mechanism for mapping the first index to the most rapidly varying data. We</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="stringliteral">recommend the former if possible. The disadvantage of the latter is that many</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="stringliteral">of numpy&#39;s functions will yield arrays without Fortran ordering unless you are</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="stringliteral">careful to use the &#39;order&#39; keyword. Doing this would be highly inconvenient.</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="stringliteral">Otherwise we recommend simply learning to reverse the usual order of indices</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="stringliteral">when accessing elements of an array. Granted, it goes against the grain, but</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="stringliteral">it is more in line with Python semantics and the natural order of the data.</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="stringliteral">&quot;&quot;&quot;</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="keyword">from</span> __future__ <span class="keyword">import</span> division, absolute_import, print_function</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
